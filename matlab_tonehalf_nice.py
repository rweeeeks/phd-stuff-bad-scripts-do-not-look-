# -*- coding: utf-8 -*-
"""matlab-tonehalf_nice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cniSz2Xh7ZhSEUB31RlneiJJ_QhNoXYN
"""

!pip install matlab

import io
import numpy as np
import pandas as pd
from google.colab import files

# Upload the Excel file
uploaded = files.upload()

# Read the uploaded file into a pandas DataFrame
filename = list(uploaded.keys())[0]
data = pd.read_excel(io.BytesIO(uploaded[filename]))

# Extract x and y values
x = data.iloc[:, 0].values
y = data.iloc[:, 1:].values

# Calculate the baseline (average of the first 10 y values)
baseline = np.mean(y[:10, :], axis=0)

# Calculate the maximum (average of the 5 highest values outside the baseline)
max_values = np.sort(y[10:, :], axis=0)[-5:, :]
maximum = np.mean(max_values, axis=0)

# Initialize half_maximum with NaN values
half_maximum = np.full(maximum.shape, np.nan)

# Calculate the half maximum only if the maximum is greater than the baseline
valid_indices = maximum > baseline
half_maximum[valid_indices] = (baseline[valid_indices] + maximum[valid_indices]) / 2

# Find the time to half maximum with linear interpolation
time_to_half_max = np.full(y.shape[1], np.nan)
for i in range(y.shape[1]):
    above_half_max = np.where(y[10:, i] > half_maximum[i])[0]
    if above_half_max.size > 0:
        idx = above_half_max[0] + 10
        if idx > 0 and idx < len(x) - 1:
            x1, x2 = x[idx - 1], x[idx]
            y1, y2 = y[idx - 1, i], y[idx, i]
            # Linear interpolation
            time_to_half_max[i] = x1 + (half_maximum[i] - y1) * (x2 - x1) / (y2 - y1)

# Print the baseline and maximum values
print('Baseline values:')
print(baseline)
print('Maximum values:')
print(maximum)

# Export the time to half maximum data to a new Excel file
output_df = pd.DataFrame(time_to_half_max).transpose()
output_df.to_excel('time_to_half_max.xlsx', index=False, header=False)

# Download the file
files.download('time_to_half_max.xlsx')